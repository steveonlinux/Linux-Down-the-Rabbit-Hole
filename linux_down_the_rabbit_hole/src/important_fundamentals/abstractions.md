# What is an Abstraction?

At the end of the day everything on a computing system is a binary data field. 0s and 1s. However,  manually dealing with the bits required to perform any task meaningfully is impossible for a human. Especially on a modern computer. This is why we deal with abstractions in the computing world. Such that, everything on a computer that isn't a bit, is technically an abstraction. However, generally, bits are abstracted in some way that is then abstracted itself, and then that abstraction is abstracted... and so forth. Here we would say there are *layers of abstraction*. From your web browser, to your text editor. To your operating system user account and your graphical user interface. To your email client and the internet connection you use to send mail. The very text you now read to data types such as ints or floats in your favorite programming language. are all abstractions of some more fundamental data structure. The details of which are obfuscated by the abstraction to make the data more digestible and usable by a human. In short, abstractions exist so that one can interact with the abstraction instead of what is being abstracted itself.

Unix and Unix-like operating systems such as Linux utilize abstractions that differentiate this family of systems from others, And arguably these abstractions make Unix-like operating systems unparalleled in their simplicity and elegance, in an almost magical way.

## Files
In Linux *everything is a file*... for our purposes at least. The implications of this are far reaching. On Linux, you can easily access and manipulate data in a way unparalleled by other systems. Data isn't accessed using APIs, function calls, or lookups in databases or registries. Fundamentally, all the information you'll need is just in a file somewhere. And all the information being exchanged by processes and resources are simply being exchanged between files or landing in a file somewhere on the filesystem. Furthermore, files on Linux are *typeless*. The metadata for a file isn't stored in the file itself, but somewhere else called an *inode*. Therefore, the data in files is agnostic. It's just data. Meaning data can be exchanged between processes and resources in Linux extremely easily. And even the state of lower level system information is reflected as files on the filesystem via the `/proc` directory. This kind of convenient and direct access to the system state, and all information on the system for that matter, puts Linux above the rest in terms of accessibility. Much more on files, inodes, and `/proc` is discussed in the later chapter: [File Structure, File Systems, & Permissions
]()

## Pipes & Streams
Recall for the previous section that files are typeless, and that the data in files is more or less agnostic. If you combine this notion with the utility of pipes and streams, the power of the Unix design philosophy is realized and apparent. A *pipe* is an operator that sends the output of a command, program, or process to the input of another. And all programs utilize data `streams` that carry data to the ins and outs of other programs. And the data in these streams can be *redirected* to other streams by the user. If you combine this concept with data agnosticism, you have a system where all programs follow a standard that allow them to interact and communicate directly with every other program. **THIS IS POWERFUL** Programs can effectively be stitched and glued together to accomplish anything on the system. The power at the fingertips of a user of a Linux system is extraordinary because of this. You will learn more about pipes and streams and how to use them in the later chapter: [Terminals, Terminal Emulators, Shells, & the Command Line](./../term/README.md)
